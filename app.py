# -*- coding: utf-8 -*-
"""streamlit.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RGqy8LEBrjho26fJrIWYeLoHOZLFV6Vr
"""

import streamlit as st
import os
import pickle
import numpy as np
import tensorflow as tf
from music21 import converter, stream, note, chord, instrument
from pyngrok import ngrok


# Load the model and data
@st.cache_resource
def load_model_and_data():
    model = tf.keras.models.load_model('music_model.h5'
                                       ,custom_objects={'accuracy': tf.keras.metrics.Accuracy()})
    model.compile(loss='categorical_crossentropy',
                  optimizer='adam',
                  metrics=['accuracy'])
    with open('training_history1.pkl', 'rb') as f:
        data = pickle.load(f)
    

    return model,data

# Load model and data
model, data = load_model_and_data()
notes = data.get('notes', [])  # Get 'notes' if it exists, else an empty list
vocab_size = data.get('vocab_size', 0)  # Similarly for other keys
sequence_length = data.get('sequence_length', 0)


def prepare_sequences(notes, sequence_length, vocab_size):
    if len(notes) < sequence_length:
        st.error(f"The uploaded MIDI file is too short. It needs at least {sequence_length} notes.")
        return None

    # Create a dictionary of pitch integers and the corresponding indices
    pitchnames = sorted(set(item for item in notes))
    note_to_int = dict((note, number) for number, note in enumerate(pitchnames))
    
    network_input = []
    for i in range(0, len(notes) - sequence_length, 1):
        sequence_in = notes[i:i + sequence_length]
        network_input.append([note_to_int[char] for char in sequence_in])
    
    return np.reshape(network_input, (len(network_input), sequence_length, 1)) / float(vocab_size)



def generate_music(model, start_sequence, num_notes_to_generate, vocab_size, sequence_length):
    if len(start_sequence) < sequence_length:
        st.error(f"Not enough notes to generate music. Need at least {sequence_length} notes.")
        return None

    pitchnames = sorted(set(start_sequence))
    note_to_int = dict((note, number) for number, note in enumerate(pitchnames))
    int_to_note = dict((number, note) for number, note in enumerate(pitchnames))
    
    pattern = [note_to_int[note] for note in start_sequence]
    prediction_output = []

    for _ in range(num_notes_to_generate):
        prediction_input = np.reshape(pattern, (1, len(pattern), 1))
        prediction_input = prediction_input / float(vocab_size)
        
        prediction = model.predict(prediction_input, verbose=0)
        index = np.argmax(prediction)
        result = int_to_note[index]
        prediction_output.append(result)
        
        pattern.append(index)
        pattern = pattern[1:len(pattern)]

    return prediction_output

def create_midi_and_sheet_music(notes, output_dir):
    output_notes = []
    offset = 0

    for note_value in notes:
        new_note = note.Note(note_value)
        new_note.offset = offset
        new_note.storedInstrument = instrument.Piano()
        output_notes.append(new_note)
        offset += 0.5

    midi_stream = stream.Stream(output_notes)

    os.makedirs(output_dir, exist_ok=True)

    midi_file_path = os.path.join(output_dir, 'generated_music.mid')
    midi_stream.write('midi', fp=midi_file_path)

    xml_file_path = os.path.join(output_dir, 'generated_music.musicxml')
    midi_stream.write('musicxml', fp=xml_file_path)

    return midi_file_path, xml_file_path

# Streamlit app
st.title('AI Music Generator')



# File uploader
uploaded_file = st.file_uploader("Choose a MIDI file", type="mid")

# In your Streamlit app:
if uploaded_file is not None:
    # Save the uploaded file temporarily
    with open("temp.mid", "wb") as f:
        f.write(uploaded_file.getbuffer())
    
    # Extract notes from the uploaded file
    try:
        midi = converter.parse("temp.mid")
        notes_to_parse = midi.flat.notesAndRests
        uploaded_notes = []
        for element in notes_to_parse:
            if isinstance(element, note.Note):
                uploaded_notes.append(str(element.pitch))
            elif isinstance(element, chord.Chord):
                uploaded_notes.append('.'.join(str(n) for n in element.normalOrder))
        
        if not uploaded_notes:
            st.error("No recognizable notes found in the uploaded MIDI file.")
        else:
            st.success(f"Successfully extracted {len(uploaded_notes)} notes from the MIDI file.")
    except Exception as e:
        st.error(f"Error processing MIDI file: {str(e)}")
        uploaded_notes = []

    # Generate new music
    if st.button('Generate Music') and uploaded_notes:
        prepared_sequence = prepare_sequences(uploaded_notes, sequence_length, vocab_size)
        if prepared_sequence is not None:
            start_sequence = uploaded_notes[:sequence_length]
            generated_notes = generate_music(model, start_sequence, 500, vocab_size, sequence_length)
            
            if generated_notes:
                # Create MIDI and sheet music
                output_dir = 'C:\\Users\\georg\\OneDrive\\Documents'
                midi_path, xml_path = create_midi_and_sheet_music(generated_notes, output_dir)
                
                st.success('Music generated successfully!')
                
                # Provide download links
                with open(midi_path, "rb") as file:
                    st.download_button(
                        label="Download MIDI",
                        data=file,
                        file_name="generated_music.mid",
                        mime="audio/midi"
                    )
                
                with open(xml_path, "rb") as file:
                    st.download_button(
                        label="Download Sheet Music (MusicXML)",
                        data=file,
                        file_name="generated_music.musicxml",
                        mime="application/vnd.recordare.musicxml+xml"
                    )
            else:
                st.error("Failed to generate music. Please try a different MIDI file.")
    elif not uploaded_notes:
        st.warning("Please upload a valid MIDI file before generating music.")
# Clean up
if os.path.exists("temp.mid"):
    os.remove("temp.mid")



